**1. Ofuscación de Strings y APIs**  
Ofuscar cadenas sensibles como nombres de API (ej. VirtualAlloc, CreateRemoteThread) usando codificación, fragmentación o hashing evita la detección estática basada en patrones de cadenas.

**2. Encriptación de Shellcode**  
Cifrar payloads (XOR, AES, RC4) y descifrarlos en tiempo de ejecución evita firmas estáticas y dificulta la ingeniería inversa.

**3. Inyección Reflexiva de DLL**  
Carga una DLL directamente en memoria sin escribir en disco. Evade AV tradicional y varios controles EDR si se hace bien.

**4. Process Hollowing**  
Un proceso legítimo se inicia en modo suspendido, se reemplaza su memoria por código malicioso y luego se reanuda. El proceso padre parece legítimo y evade detecciones de comportamiento.

**5. Process Doppelgänging**  
Exploita características de NTFS para ejecutar código de un ejecutable modificado sin escribirlo en disco permanentemente, dificultando la detección.

**6. Desenganche de Hooks en EDR**  
Los EDR suelen enganchar APIs en _ntdll.dll_. Restaurar manualmente los syscalls limpios o remapear _ntdll.dll_ elimina esos hooks.

**7. Hashing de API y Syscalls Directos**  
Resolver APIs en tiempo de ejecución mediante hashes o invocar syscalls directamente evita APIs enganchadas.

**8. Living off the Land (LOLBins)**  
Uso de binarios legítimos de Windows (mshta.exe, regsvr32.exe, rundll32.exe) para ejecutar código malicioso, confiando en que AV los considere seguros.

**9. Spoofing del Proceso Padre**  
Manipular el _Parent Process ID_ para que el proceso malicioso parezca creado por uno confiable (ej. explorer.exe).

**10. Syscalls Indirectos**  
Usar ensamblador y números de syscalls en lugar de APIs de Windows evita hooks en modo usuario de EDR.

**11. Sobrescribir Hooks Inline**  
Restaurar bytes originales en funciones enganchadas (ej. kernel32.dll o ntdll.dll) anula la visibilidad del EDR.

**12. Staging Remoto o por DNS**  
Dividir payloads en fragmentos pequeños y cargarlos vía registros DNS TXT o desde la nube evita detección en la entrega.

**13. Relleno Binario y Código Basura**  
Insertar NOPs, saltos inútiles o randomizar estructuras cambia los hashes y evita detecciones por firma.

**14. Encabezados PE Personalizados o Packers**  
Modificar headers, secciones o usar packers (UPX, MPRESS, custom) confunde escáneres estáticos.

**15. Ejecución Proxy de Binarios Firmados**  
Algunos binarios firmados de Windows permiten ejecución de código (ej. InstallUtil.exe, PresentationHost.exe), saltando controles de lista blanca.

**16. Chequeos de Entorno**  
El malware detecta sandbox/VM/debuggers y retrasa o detiene ejecución para evadir análisis.

**17. Técnicas C2 con Sleep y Jitter**  
Agentes maliciosos esperan largos periodos con intervalos aleatorios para reducir huella en red y evitar detección temporal.

**18. Bypass de AMSI**  
Parchear o deshabilitar la función _AmsiScanBuffer_ evita el análisis de AMSI en PowerShell y scripts.

**19. Patching de ETW**  
Deshabilitar o modificar _Event Tracing for Windows_ oculta eventos de comportamiento a los EDR, especialmente en PowerShell o .NET.

**20. Configuración Encriptada**  
Guardar URLs de C2, claves y configs en formato cifrado/encoded dificulta el análisis estático.

**21. Alternate Data Streams (ADS)**  
NTFS permite ocultar datos en streams alternativos invisibles para escáneres básicos.

**22. Inyección con APIs Nativas**  
Usar APIs de bajo nivel (NtWriteVirtualMemory, NtCreateThreadEx) en lugar de las de alto nivel (CreateRemoteThread), menos monitorizadas.

**23. Ofuscación de Tráfico C2 y Domain Fronting**  
Disfrazar C2 usando CDNs o domain fronting lo mezcla con tráfico legítimo, evadiendo detección por patrones.

**24. Timestomping**  
Modificar timestamps de archivos para que coincidan con archivos legítimos del sistema, dificultando análisis forense.

**25. Abuso de Herramientas de Doble Uso**  
Uso de utilidades legítimas (certutil.exe, bitsadmin.exe, powershell.exe) para descargar/ejecutar código. Al estar firmadas por Microsoft, AV rara vez las bloquea.

---

👉 Estas técnicas muestran cómo la evasión de AV/EDR requiere no solo herramientas, sino también un conocimiento profundo de los **internos del SO, superficies de detección y OpSec ofensivo**.